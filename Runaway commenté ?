##################
# initialisation #
##################

#importation des modules : ##########
from tkinter import *
from time import *
from random import *

# CrÃ©ation d'une interface graphique : ##########

fenetre = Tk()
canvas = Canvas(fenetre, width=450, height=200, background='orange')

##############
# variobles  #
##############

# Variables pour le personnage : ##########
## Position du personnage (coordonnÃ©es)
pob1 = 10
pob2 = 135
pob3 = 60
pob4 = 185
pnj = canvas.create_oval(pob1, pob2, pob3, pob4,fill='orange')

## Variables pour le saut
jumping = 0
## Vitesse de saut (pour un effet de gravitÃ©. voir sous-programme "jump")
inispeed = 8
speed = 8 ## la valeur de speed sera changÃ©e, et on reviendra Ã  inispeed.

# Variables pour le dÃ©cors : ##########
## Couleur du dÃ©cor (fond)
colordecor = "#AB6300"

## DÃ©cor (sol)
coo1 = 550
coo2 = 570
decorsolcoor = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  ## Stock les coordonnÃ©es
decorsol = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  ## Stock les objets du canvas

ligne1 = canvas.create_line(0,180, 450, 180)
ligne2 = canvas.create_line(0,3,460,3)

x = canvas.create_line(coo1, 180, coo2, 190, coo2,205)  ## crÃ©Ã© la 2Ã¨me ligne du sol
x = (canvas.coords(x))

## Position du dÃ©cor
pod1 = 450
pod2 = 500
pod3 = 490
pod4 = 460

## Colonne en fond
decor = canvas.create_polygon(pod1, 1, pod2, 1, pod3, 15, pod3, 180, pod4, 180, pod4, 15, fill='#D77301', outline='black', width='1')

## Activation du dÃ©cor (voir decordef)
decoractive = False

# Vaiables pour les obstacles : ##########
## Stockage des obstacles. (voir "new_objet")
obstacle = []

## type d'obstacle gÃ©nÃ©rÃ© alÃ©atoirement (voir "random_objet" et "new_objet")
random_item = 0

## Permet d'Ã©viter de lancer la fonction "defilement" plusieurs fois en mÃªme temps
flag = 0

# Variables pour les fonctionnalitÃ©es du jeu : ##########
## DifficultÃ© qui augmente au fur et Ã  mesure
dif = 3

## Variable qui dÃ©tecte la fin
finish = False

## compteur (score)
score = 0

## mode de jeu
mode = 0

# Bouton : ##########
bouton=Button(fenetre, text="Fermer", command=fenetre.destroy)

###################
# sous-programmes #
###################

# Saut du personnage (jump + fall) : ##########

def clickl(event):
    global jumping, speed
    if jumping == 0:
        jumping += 1
        jump()
    elif jumping == 1:
        jumping += 1
        speed = inispeed
        doublejump()

def jump():
    global pob2, pob4, speed, jumping
    if jumping == 1 :
        if speed > 0:
            canvas.coords(pnj,pob1,pob2,pob3,pob4)
            pob2 -= speed
            pob4 -= speed
            speed -= 0.5
            canvas.after(10,jump)
        else:
            canvas.after(10, fall)

def fall():
    global pob2, pob4, jumping, speed
    if jumping == 1:
        if speed < inispeed+0.5:
            canvas.coords(pnj,pob1,pob2,pob3,pob4)
            pob2 += speed
            pob4 += speed
            speed += 0.5
            canvas.after(10,fall)
        else:
            pob2=135
            pob4=185
            canvas.coords(pnj,pob1,pob2,pob3,pob4)
            speed = inispeed
            jumping -= 1

# ...Et le double saut : ##########
def doublejump():
    global jumping, speed, pob2, pob4
    if speed > 0:
        canvas.coords(pnj, pob1, pob2, pob3, pob4)
        pob2 -= speed
        pob4 -= speed
        speed -= 0.5
        canvas.after(10, doublejump)
    else:
        canvas.after(10, doublefall)

def doublefall():
    global jumping, speed, pob2, pob4
    if (canvas.coords(pnj)[0], canvas.coords(pnj)[1], canvas.coords(pnj)[2], canvas.coords(pnj)[3]) < (10.0, 135, 60, 185):
    #if (canvas.find_overlapping(10, 135, 60, 185))[1] != 14: # (3,4) not in 4 ?
        canvas.coords(pnj, pob1, pob2, pob3, pob4)
        pob2 += speed
        pob4 += speed
        speed += 0.5
        canvas.after(10, doublefall)
    else:
        pob2 = 135
        pob4 = 185
        canvas.coords(pnj, pob1, pob2, pob3, pob4)
        speed = inispeed
        jumping = 0

# DÃ©cor : ##########

def clickr(event):
    global decoractive
    if decoractive == False:
        decoractive = True
        decordef()
    else:
        decoractive = False
        decordef()

## DÃ©placement du dÃ©cor

def decordef():
    global decoractive, pod1, pod2, pod3, pod4
    if decoractive == True:
        if pod2 > 0:
            canvas.coords(decor, pod1, 3, pod2, 3, pod3, 15, pod3, 180, pod4, 180, pod4, 15,)
            pod1,pod2,pod3,pod4 = pod1-dif,pod2-dif,pod3-dif,pod4-dif
            canvas.after(10, decordef)
        else:
            pod1 = 450
            pod2 = 500
            pod3 = 490
            pod4 = 460
            canvas.after(10, decordef)
def move():
    global decorsolcoor, compteur, decorsol, compteur2
    if compteur2 < 25:  # compteur2 sert Ã  compter le dÃ©placement des lignes
        for item in decorsolcoor:  # On utilise decorsol pour les objets, et item pour dÃ©finir les coordonnÃ©es
            item[0] -= 2
            item[2] -= 2
            item[4] -= 2
            canvas.coords(decorsol[compteur], item[0],
                          180, item[2], 190, item[4], 205)
            compteur += 1
        compteur = 0  # compteur est incrÃ©mentÃ© de 0 Ã  10, pour prendre toutes les valeurs de la liste decorsol
        compteur2 += 1
        canvas.after(10, move)
    else:  # Si compteur2 arrive Ã  25, du coup on remet les lignes Ã  leurs positions initiales.
        for item in decorsolcoor:
            item[0] += 50
            item[2] += 50
            item[4] += 50
            canvas.coords(decorsol[compteur], item[0],
                          180, item[2], 190, item[4], 205)
            compteur += 1
        compteur = 0
        compteur2 = 0
        canvas.after(10, move)


compteur = 0
canvas.after(10, move)

ligne2 = canvas.create_line(0, 190, 460, 190)

for y in range(1, 12):  # CrÃ©ation des objets
    compteur = -1  # le compteur est incrÃ©mentÃ©, et dÃ©fini la position de chaque objet dans les listes
    for i in x:
        compteur += 1
        if x[compteur] not in [1, 3, 5]:  # On ne modifie que les valeurs en x, pas en y
            i -= 50
            x[compteur] = i
    decorsol[y] = canvas.create_line(
        x[0], 180, x[2], 190, x[4], 205)  # On utilise les valeurs de x
    decorsolcoor[y] = (canvas.coords(decorsol[y]))

decorsol[0] = [coo1, 180, coo2, 190, coo2, 205]
decorsolcoor[0] = [coo1, 180, coo2, 190, coo2, 205]

compteur2 = 0

# Obstacles : ##########
## installe un temps entre chaque obstacle
def generation():
    go = int(random()*100)
    if go != 1:
        fenetre.after(1000, generation)
    random_objet()
## Puis genere un type d'obstacle...
def random_objet():
    global random_item
    random_item = int(random()*5)
    new_objet()
## ...Et le cree
def new_objet():
    global flag, finish
    if finish == False:
        if random_item == 0: #x1,y1,x2,y2
            obstacle.append(canvas.create_line(450, 185, 465, 165))
            obstacle.append(canvas.create_line(465, 165, 480, 185))
        if random_item == 1:
            obstacle.append(canvas.create_line(450, 185, 465, 165))
            obstacle.append(canvas.create_line(465, 165, 480, 185))
            obstacle.append(canvas.create_line(480, 185, 495, 165))
            obstacle.append(canvas.create_line(495, 165, 510, 185))
        if random_item == 2:
            obstacle.append(canvas.create_line(450, 185, 465, 165))
            obstacle.append(canvas.create_line(465, 165, 480, 185))
            obstacle.append(canvas.create_line(480, 185, 480, 165))
            obstacle.append(canvas.create_line(480, 165, 500, 165))
            obstacle.append(canvas.create_line(500, 165, 500, 185))
        if random_item == 3:
            obstacle.append(canvas.create_line(480, 165, 490, 150))
            obstacle.append(canvas.create_line(490, 150, 500, 165))
            obstacle.append(canvas.create_line(480, 185, 480, 165))
            obstacle.append(canvas.create_line(480, 165, 500, 165))
            obstacle.append(canvas.create_line(500, 165, 500, 185))
        if flag == 0:
            defilement()
            flag = 1
## Enfin, l'obstacle se met Ã  bouger
def defilement():
    global y_objet, x_objet, finish
    if finish == False:
        for objet in obstacle:
            coordonnees = canvas.coords(objet)
            if coordonnees[2] < 0:
                del obstacle[0]
                objet = 1
            else:
                canvas.coords(
                    objet, coordonnees[0]-2, coordonnees[1], coordonnees[2]-2, coordonnees[3])
        mort = (canvas.find_overlapping(canvas.coords(pnj)[0], canvas.coords(pnj)[1], canvas.coords(pnj)[2], canvas.coords(pnj)[3]))
        mortlist = list(mort)
        for i in range(0, 18):
            if i in mortlist:
                mortlist.remove(i)
        if len(mortlist) != 0:
            finish = True
            canvas.delete("all")
        else:
            fenetre.after(10, defilement)
########
# main #
########
## Appel des fonctions
fenetre.bind("<space>", clickl)
fenetre.bind("<d>", clickr)

generation() ## lancement des obstacles

## Activation (pack)
bouton.pack()
canvas.pack()

## permet de dÃ©finir la position (au-dessous ou au-dessus de l'Ã©lÃ©ment spÃ©cifiÃ©)
canvas.tag_raise(pnj, decor)
canvas.tag_raise(pnj,ligne2)

fenetre.mainloop()
